#### 在项目开发中，接口与接口之间，前后端之间数据的传输都使用 Json 格式，在 Spring Boot 中，接口返回 Json 格式的数据很简单，在 Controller 中使用@RestController注解即可返回 Json 格式的数据，@RestController也是 Spring Boot 新增的一个注解

# 1后端项目三层架构

### web层（controller）

只负责跟前端交互，接收请求，响应结果

### 业务层（service）

负责处理业务逻辑

### 持久层（Dao/Mapper）

只负责执行SQL，访问数据库中的数据

## 三层关系：

### 下层给上层提供服务

web层个前端提供接口服务；

业务层给web层提供业务服务；

持久层给业务层提供数据服务；

### 上层依赖下层

上层需要调用下层的方法完成需要的功能



# 2 接口开发基本步骤

### 2.1 开发第一个后端API接口

开发后端API接口可以选择Servlet，也可以直接使用SpringMVC框架.

#### 2.1.1 SpringMVC框架

SpringMVC框架是一个web层的MVC框架,可以用来开发Web API接口.

- 第一步： 导入SpringMVC框架的依赖

  ```xml
  <dependency>
      <groupId>org.springframework.boot</groupId>
      <artifactId>spring-boot-starter-web</artifactId>
  </dependency>Copy
  ```

- 第二步：开发API接口

  - 创建一个Controller控制器类: 控制器类中就包含多个API接口

    Controller类是一个spring bean组件：一定要放在main主类所在的包下.

    ```java
    @RestController//标注这个类是一个Controller控制器
    public class AdminIndexController {
    
    }Copy
    ```

  - 在Controller类中添加控制器方法，每个控制器方法就是一个API接口

    ```java
      @RequestMapping("/admin/user/count")//标注这个方法是一个API接口方法,并指定访问路径
        public Object selectAdminUserCount(){
            return null;
        }Copy
    ```

    

#### 2.1.2 Mybatis框架

Mybatis框架是一个持久层的orm框架，可以用来连接访问数据库.

- 依赖

  - mybatis

    ```xml
    <dependency>
        <groupId>org.mybatis.spring.boot</groupId>
        <artifactId>mybatis-spring-boot-starter</artifactId>
        <version>1.3.2</version>
    </dependency>Copy
    ```

  - mysql

    ```xml
    <dependency>
        <groupId>mysql</groupId>
        <artifactId>mysql-connector-java</artifactId>
    </dependency>
    ```

  - datasource

    - 可以使用spring自带的，就不需要再导入数据源依赖

  - 也可以使用其他数据源

    - c3p0
      - dbcp
    - druid
    - 等等

- 配置

  springboot项目的配置都在resources目录下的application.properties文件:

  - 数据源

    ```properties
    # 数据源
    spring.datasource.driver-class-name=com.mysql.jdbc.Driver
    spring.datasource.url=jdbc:mysql://localhost:3306/easy_mall?serverTimezone=PRC
    spring.datasource.username=root
    spring.datasource.password=123456Copy
    ```

  - mybatis

    #类别别名

    ```properties
    mybatis.type-aliases-package=com.example.emall.domain
    ```

    #扫描Mapper映射文件

    ```properties
    mybatis.mapper-locations=classpath:/mapper/*Mapper.xml
    ```

- mapper接口

  定义Mapper接口，mapper接口定义用来执行sql语句的方法.

  ```java
  public interface AdminUserMapper {
      //每个方法对应一个sql语句
      public int selectAdminUserCount();
  }
  ```

- mapper映射文件

  mapper映射文件是一个xml文件，里边定义sql语句.

  建议放在resources目录下（可以新建一个目录）。

  ```xml
  <?xml version="1.0" encoding="UTF-8" ?>
  <!DOCTYPE mapper
          PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN"
          "http://mybatis.org/dtd/mybatis-3-mapper.dtd">
  <!-- namespace必须是对应的Mapper接口的全名(包名.接口名) -->
  <mapper namespace="com.edu.mall.admin.mapper.AdminUserMapper">
      <!-- id必须是对应的方法的方法名 -->
      <select id="selectAdminUserCount" resultType="int">
          select count(id) from litemall_admin
      </select>
  </mapper>Copy
  ```

  - namespace
  - id

- MapperScan

  在主类上通过MapperScan注解扫描Mapper接口

  ```java
  @MapperScan("com.edu.mall.admin.mapper")
  ```

#### 2.1.3 Controller调用Mapper

只要调用Mapper接口中的方法，就会执行对应的sql语句.

```java
@Autowired//1.注入AdminUserMapper对象
AdminUserMapper adminUserMapper;

@RequestMapping("/admin/user/count")
public Object selectAdminUserCount(){
    int count = adminUserMapper.selectAdminUserCount();//2.调用方法
    Map<String,Object> result = new HashMap<>();
    result.put("errno",0);
    result.put("errmsg","成功");
    result.put("data","管理员用户数量:"+count);
    return result;
}Copy
```

### 2.2 启动后端服务

后端springboot项目中直接内嵌了tomcat应用服务器，直接运行main主类，就可以启动tomcat并部署项目.

![image-20220722174521913](http://course.zhonghui.vip/training/doc/proj4/images/run.png)

### 2.3 接口测试工具

- 浏览器 （只能发送get请求）
  - 浏览器中安装插件
- 专业的工具
  - postman
  - ApiPost
  - curl
  - 等等

### 2.4 项目目录结构

src

 main

 java（java源码文件）

 com.edu.mall.admin(基本包)

 Application.java(主类)

 controller

 service

 mapper（即dao层）

 domain(po/pojo/model) : 跟数据库表映射的java实体类

 vo : 主要是适配接口响应结果的java类（配合前端组织数据）

 dto ：数据传输对象，比如接收前端传递过来的参数对象

 util : 工具类

 common : 与业务功能无关的通用对象

 config : 配置对象



#####  resources（资源文件）

 application.properties （配置文件）

 mapper : Mapper映射文件

 static ： 静态资源(img/css/js/font)

 templates : 模板文件(freemark/velocity/thymeleaf)

 test(测试)

 java

 resources

pom.xml     导入依赖



## 难点

lombok插件（自动封装常量配合@Data使用）

字段名=#{参数名}

```properties
#下划线<--->驼峰式
mybatis.configuration.map-underscore-to-camel-case=true
```



### pagehepler插件的使用(pagehepler-spring-boot-starter)

```properties
#配置方言（数据库语法）
pagehelper.helper-dialect = mysql
```

```java
//分页 
PageHelper.startPage(page,limit);
 List<GoodsCategory> list = goodsCategoryService.selectGoodsCategoryList();
//分页结果
 PageInfo<GoodsCategory> pageInfo = new PageInfo<>(list);
```



### token插件的使用（java-jwt）



### 类型处理器（TypeHandler<String[]>）

```properties
#类型处理器
mybatis.type-handlers-package=com.example.emalllogin.mapper.handler
```



ObjectMapper(Jackson的json解析工具对象)

objectMapper.writeValueAsString(parameter) ;          （java） String[]转换为（ 数据库） JSON数组

objectMapper.readValue(json,String[].class) ;               JSON转String[]

注册 mybatis.type-handlers-package=  com.it.emall.mapper.handler  (指一下文件位置)

### 映射字段，指定类型处理器

```xml
<resultMap id="goodsMap" type="goods">
    <!-- 映射字段，指定类型处理器 -->
    <result column="gallery" property="gallery" typeHandler="com.example.emalllogin.mapper.headler.StringArrayTypeHandler" />
</resultMap>
```

### 文件上传模块

MultipartFile

UUID

### 注解释义

- @RequestMapping

  这个注解可以自己指定支持的请求方式   

- @GetMapping

  这个注解只支持Get请求方式

-  @PostMapping

  这个注解只支持Post请求方式

- @PutMapping

  这个注解只支持Put请求方式

- @DeleteMapping

  这个注解只支持Delete请求方式

- @Autowired  

  把UserMapper类型的对象自动注入进来

  ```java
  private UserMapper userMapper;
  ```

  

- @Override

  表示子类重写父类的方法

  1. 可以当注释用，方便阅读（注解很重要的一个作用就是注释）；
  2. 编译器和 IDE 可以验证 @Override 下面的方法名是否是父类中所有的，如果没有的话就会报错。如果没有加 @Override ，而子类中的方法名又写错了，这个时候编译器是可以编译通过的，因为编译器以为这个方法是你的子类中自己增加的方法。

- @RequestBody

  接收json格式参数

- @RestController

  标注这个类是一个Controller控制器

- @Service

  注解用于标记一个类作为服务类，表示该类提供了业务逻辑的实现

- @CrossOrigin

  在Controller类里加入解决该接口跨域问题

- @Component是一个通用的组件类注解，表示该类可被自动扫描并装配到Spring容器中

  定义组件类

- @Configuration注解表明该类是一个配置类，在这个类中可以定义bean，可以使用Java代码来替代传统的XML配置文件。

- @RequestParam

  属性value,name,required,defaultValue

  接收前端发出的参数

- @Param

  Mapper层方法带多个参数时，要用该注解起给各个参数取别名来区分参数

- 等等

