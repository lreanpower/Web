[TOC]

Integer 必须实例化才可以使用，

# 后端难点

在项目开发中，接口与接口之间，前后端之间数据的传输都使用 Json 格式，在 Spring Boot 中，接口返回 Json 格式的数据很简单，在 Controller 中使用@RestController注解即可返回 Json 格式的数据，@RestController也是 Spring Boot 新增的一个注解

## 1.依赖项

```xml
 <dependency>
       <groupId>org.springframework.boot</groupId>
       <artifactId>spring-boot-starter-web</artifactId>
 </dependency>
  <dependency>
       <groupId>org.mybatis.spring.boot</groupId>
       <artifactId>mybatis-spring-boot-starter</artifactId>
       <version>2.2.1</version>
 </dependency>
 <dependency>
       <groupId>mysql</groupId>
       <artifactId>mysql-connector-java</artifactId>
       <version>8.0.31</version>
</dependency>
```

### lombok插件

（自动封装常量配合@Data使用）

### pagehepler插件

  (pagehepler-spring-boot-starter)

```properties
#配置方言（数据库语法）
pagehelper.helper-dialect = mysql
```

```java
//分页 
PageHelper.startPage(pageNum,pageSize);
//查询结果
 List<GoodsCategory> list = goodsCategoryService.selectGoodsCategoryList();
//对查询返回的list集合进行自动分页
 PageInfo<GoodsCategory> pageInfo = new PageInfo<>(list);
```

### token生成插件

（java-jwt）

```java
/**
*不用记，直接复制粘贴
*/
package com.example.emalllogin.util;

import com.auth0.jwt.JWT;
import com.auth0.jwt.JWTVerifier;
import com.auth0.jwt.algorithms.Algorithm;
import com.auth0.jwt.exceptions.JWTCreationException;
import com.auth0.jwt.exceptions.JWTVerificationException;
import com.auth0.jwt.interfaces.Claim;
import com.auth0.jwt.interfaces.DecodedJWT;

import java.util.*;

/**
 * token的生成和验证
 */
public class JwtHelper {
        // 秘钥
        static final String SECRET = "Easymall-Token";
        // 签名是有谁生成
        static final String ISSUSER = "EASYMALL";
        // 签名的主题
        static final String SUBJECT = "this is easymall token";
        // 签名的观众
        static final String AUDIENCE = "MOBILEWEBAPP";

        /**
         * 生成token
         * @param userId 用户ID
         * @return
         */
        public static String createToken(Long userId){
            try {
                Algorithm algorithm = Algorithm.HMAC256(SECRET);
                Map<String, Object> map = new HashMap<String, Object>();
                Date nowDate = new Date();
                // 过期时间：2小时
                Date expireDate = getAfterDate(nowDate,0,0,0,2,0,0);
                map.put("alg", "HS256");
                map.put("typ", "JWT");
                String token = JWT.create()
                        // 设置头部信息 Header
                        .withHeader(map)
                        // 设置 载荷 Payload
                        .withClaim("userId", userId)
                        .withIssuer(ISSUSER)
                        .withSubject(SUBJECT)
                        .withAudience(AUDIENCE)
                        // 生成签名的时间
                        .withIssuedAt(nowDate)
                        // 签名过期的时间
                        .withExpiresAt(expireDate)
                        // 签名 Signature
                        .sign(algorithm);
                return token;
            } catch (JWTCreationException exception){
                exception.printStackTrace();
            }
            return null;
        }

        /**
         * 解析token
         * @param token
         * @return
         */
        public static Long verifyTokenAndGetUserId(String token) {
            try {
                Algorithm algorithm = Algorithm.HMAC256(SECRET);
                JWTVerifier verifier = JWT.require(algorithm)
                        .withIssuer(ISSUSER)
                        .build();
                DecodedJWT jwt = verifier.verify(token);
                Map<String, Claim> claims = jwt.getClaims();
                Claim claim = claims.get("userId");
                return claim.asLong();
            } catch (JWTVerificationException exception){
//			exception.printStackTrace();
            }
            return 0l;
        }

        public static Date getAfterDate(Date date, int year, int month, int day, int hour, int minute, int second){
            if(date == null){
                date = new Date();
            }

            Calendar cal = new GregorianCalendar();

            cal.setTime(date);
            if(year != 0){
                cal.add(Calendar.YEAR, year);
            }
            if(month != 0){
                cal.add(Calendar.MONTH, month);
            }
            if(day != 0){
                cal.add(Calendar.DATE, day);
            }
            if(hour != 0){
                cal.add(Calendar.HOUR_OF_DAY, hour);
            }
            if(minute != 0){
                cal.add(Calendar.MINUTE, minute);
            }
            if(second != 0){
                cal.add(Calendar.SECOND, second);
            }
            return cal.getTime();
        }


}

```



## 2.接口类

### mybatis类型处理器

（TypeHandler<String[]>）

varchar<----->String[]

```properties
#类型处理器
mybatis.type-handlers-package=com.example.emalllogin.mapper.handler
```



ObjectMapper(Jackson的json解析工具对象)

objectMapper.writeValueAsString(parameter) ;          （java） String[]转换为（ 数据库） JSON数组

objectMapper.readValue(json,String[].class) ;               JSON转String[]

注册 mybatis.type-handlers-package=  com.it.emall.mapper.handler  (指一下文件位置)



映射字段，指定类型处理器

```xml
<resultMap id="goodsMap" type="goods">
    <!-- 映射字段，指定类型处理器 -->
    <result column="gallery" property="gallery" typeHandler="com.example.emalllogin.mapper.headler.StringArrayTypeHandler" />
</resultMap>
```

### 文件上传模块

```java

/**
 * WebMvc相关配置
 */
@Configuration
public class WebMvcConfig implements WebMvcConfigurer {
    @Override
    public void addResourceHandlers(ResourceHandlerRegistry registry) {
        //把资源的访问路径和存储位置映射起来
        registry.addResourceHandler(FileUploadConstants.FILE_URL+"**")
                .addResourceLocations("file:"+FileUploadConstants.SAVE_DIR);
//        WebMvcConfigurer.super.addResourceHandlers(registry);

    }
```



```java
@RestController
public class StorageController {
    @PostMapping("/admin/storage/create")
  public Object upload(MultipartFile file) {
      //保存根目录
      File saveDir = new File(FileUploadConstants.SAVE_DIR);
      if (file != null && !file.isEmpty()) {
          if(!saveDir.exists())
          saveDir.mkdirs();
          //文件名
          String originalFilename = file.getOriginalFilename();//原文件名
          String filename = UUID.randomUUID() + originalFilename.substring(originalFilename.lastIndexOf("."));
          //保存
          File saveFile = new File(saveDir, filename);
          try {
              file.transferTo(saveFile);
              Map<String,Object> data = new HashMap<>();
              data.put("url",FileUploadConstants.SERVER_HOST+FileUploadConstants.FILE_URL+filename);
              return AjaxResult.success(data);
          } catch (IOException e) {
              e.printStackTrace();
              return AjaxResult.fail(1, "上传失败");
          }
      }else{
          return AjaxResult.fail(1, "上传文件为空");
      }
    }
}
```



MultipartFile

UUID

## 3.注解

###     Controller层

- ##### @RestController标注这个类是一个Controller控制器

- #### @CrossOrigin在Controller类里加入解决该接口跨域问题

- ##### @RequestMapping这个注解可以自己指定支持的请求方式  

- @GetMapping这个注解只支持Get请求方式

- @PostMapping这个注解只支持Post请求方式

- @PutMapping这个注解只支持Put请求方式

- @DeleteMapping这个注解只支持Delete请求方式

- ##### @RequestHeader这个注解标明该接口请求时header头部需要携带设置的参数

- ##### @RequestParam属性value,name,required,defaultValue接收前端发出的参数

- ##### @RequestBody接收json格式参数

- #### 在前端传递@PathVariable，需要在URL中使用占位符来表示变量，然后在发送请求时，将变量的值传递给后端。例如，如果后端的URL为"/users/{id}"，则前端可以使用以下方式传递变量值：

  @PathVariable 映射 URL 绑定的[占位符](https://so.csdn.net/so/search?q=占位符&spm=1001.2101.3001.7020)
  通过 @PathVariable 可以将 URL 中占位符参数绑定到控制器处理方法的入参中:URL 中的 {xxx} 占位符可以通过

  @PathVariable(“xxx”) 绑定到操作方法的入参中。

  ```java
  @RequestMapping("/getUserById/{name}")
      public User getUser(@PathVariable("name") String name){
          return userService.selectUser(name);
      }
  ```

  1、若方法参数名称和需要绑定的url中变量名称一致时,可以简写:

  ```java
  @RequestMapping("/getUser/{name}")
      public User getUser(@PathVariable String name){
          return userService.selectUser(name);
      }
  
  ```

  2、若方法参数名称和需要绑定的url中变量名称不一致时，写成:

  ```java
  @RequestMapping("/getUserById/{name}")
      public User getUser(@PathVariable("name") String userName){
          return userService.selectUser(userName);
      }
  
  ```

- ##### @Autowired  把UserMapper类型的对象自动注入进来

  ```java
  private UserMapper userMapper;
  ```

- ##### @Override表示子类重写父类的方法

  1. 可以当注释用，方便阅读（注解很重要的一个作用就是注释）；
  2. 编译器和 IDE 可以验证 @Override 下面的方法名是否是父类中所有的，如果没有的话就会报错。如果没有加 @Override ，而子类中的方法名又写错了，这个时候编译器是可以编译通过的，因为编译器以为这个方法是你的子类中自己增加的方法。

### Service层

- ##### @Service注解用于标记一个类作为服务类，表示该类提供了业务逻辑的实现(在impl接口实现类里)

### Mapper层

- ##### @Param注解用于Mapper层方法带多个参数时，要用该注解起给各个参数取别名来区分参数

### 其他层

- @Configuration注解表明该类是一个配置类，在这个类中可以定义bean，可以使用Java代码来替代传统的XML配置文件。

- @Component是一个通用的组件类注解，表示该类可被自动扫描并装配到Spring容器中


定义组件类





## 4.mybatis的SQL语句(在xml文件中)

### 常见写法

### ORM

结果集映射（ORM）Object-Relationl Mapping

```xml
<resultMap id="唯一标识名" type="类的完全限定名" extends="继承其它结果集，避免重复书写">
    <!--<id> 主键必须使用 对底层存储有性能作用
         column="需要映射的数据库字段名"
         property="需要映射的pojo属性名"   
     -->
    <id column="" property=""></id>
    <result column="" property=""></result>
    <!--一对‘一’结果集映射-->
    <!--映射到JavaBean的某个复杂的”数据类型”属性，这个属性是一个"**对象**"，处理一对一的关联关系-->
   方式1. <result column="" property="对象属性名.属性"></result>    
   方式2.<association property="指定的‘一’"  javaType=""  column="" select="com.dkd.manage.mapper.RegionMapper.selectRegionById" columnPrefix="" resultMap=""></association>
    property:指定的‘一’
    1.自定义映射 javaType 类型
    2.重用ResultMap resultMap 调用已存在的映射，达到重用的目的
    ：强行使结果多对一，当数据不是多对一也会强行映射为多对一，并且底层是以id来组织数据，一定要把id查出来
    当出现列名和resultMap映射不一致时
     用columnPrefix:替换前缀 
    
    <!--一对‘多’结果集映射-->
    <!--映射到JavaBean的某个复杂的”数据类型”属性，这个属性是一个"**集合列表**"，处理一对多的关联关系-->
    <collection property="指定的‘多’" oftype="自定义映射" resultMap="重用ResultMap"></collection>
    
      <!---->
</resultMap>
```



### 查

```xml
 <mapper namespace="对应mapper映射路径">
   <sql id="use">${alias}.id,${alias}.username,${alias}.password </sql>定义可重用的 SQL 代码片段，以便在其它语句中    使用。 参数可以静态地（在加载的时候）确定下来，并且可以在不同的 include 元素中定义不同的参数值
    <select id="selectUsers" resultType="map">
        select
         <include refid="use"><property name="alias" value="t1"/></include>,
         <include refid="use"><property name="alias" value="t2"/></include>
        from some_table t1
          cross join some_table t2
    </select>
    <!--id的值对应方法的方法名-->
    <!--   parameterTpye可省略-->
    <!-- select-->
    <select id="selectUsername" parameterType="string" resultType="AdminUser">
        select * from litemall_admin
        where username=#{username}
    </select>
</mapper>
```



### 增删改

```xml
<mapper namespace="com.example.emalllogin.mapper.UserMapper">
 <!--   parameterTpye可省略-->
  <!--  useGeneratedKeys获取插入后自动增加的主键 和 keyProperty将自动增加的主键赋值到哪个属性中
    （仅适用于 insert 和 update） -->
   详情 https://mybatis.net.cn/sqlmap-xml.html#insert_update_and_delete
       <!--'适用于有自增的数据库'-->
       <!-- insert 返回值的为Integer类型-->
    
    <insert id="insertUsername" parameterType="AdminUser"  useGerneratedKeys="true" keyProperty="属性值">
        <!--适用于没有自增的数据库-->
        <!-- 可以在增删改之前或之后运行 -->
        <selectKey order="before|after" keyProperty="将查询结果赋值的哪个实体类属性中" resultType="id（返回值类型）">
         select max(id)+1 from litemall_book
        </selectKey>
        上面id+1赋值给下面insert里的id实现自增
        insert into litemall_admin(id,username,password)
    values (id,#{username},#{password})
    </insert>
    
    <!-- update 返回值的为Integer类型-->
    <update id="updateToken" parameterType="string">
       update litemall_admin
    set token=#{token} where username=#{username}
    </update>
    
    <!-- update  create  返回值的为void类型-->
    <update id="createTable" >
        create table ${tablename}(
            id int(20) not null auto_increment,
            name varchar(32) not null,
            addTime Date null,
            updateTime Date null,
            deleted int(3) null,
            primary key(id)
        )
    </update>
    
    <!--delete  返回值的为Boolean类型-->
    <delete id="delTable" parameterType="string">
        DROP table if exists ${tablename}
    </delete>

</mapper>
```

### 特殊写法

```xml

<!--    难点-->
    <resultMap id="goodsMap" type="goods">
        <!-- 映射字段，指定类型处理器 -->
        <result column="gallery" property="gallery" typeHandler="com.example.emalllogin.mapper.headler.StringArrayTypeHandler" />
    </resultMap> 
<!--Mybatis 中的 if 标签用于在 SQL 语句中进行条件判断。使用方法是在 SQL 语句中插入一个 <if> 标签，并在标签中定义 test 属性，test 属性的值为一个表达式，表示当该表达式为 true 时，该标签内部的 SQL 语句才会执行。-->
<select id="selectGoods"  resultMap="goodsMap">
        select * from litemall_goods
   <where>
    <if test="goodsId != null">
        and id=#{goodsId}
    </if>
    <if test="goodsSn != null">
        and goods_sn=#{goodsSn}
    </if>
    <if test="name != null and name!= ''">
        and name like concat('%',#{name},'%')
    </if>

    </where>
 </select>
```

在MyBatis中，我们可以使用#和$两种占位符号来构建SQL语句。它们的区别在于参数的处理方式，因此使用的场景也不同。 建议在以下情况下使用#：

·当我们需要将参数作为预编译语句的占位符时，应该使用#。因为#会将参数转换为JDBC预编译语句中的占位符，可以有效地防止SQL注入攻击。

·当我们需要使用OGNL表达式（如#{user.age}）访问参数对象的属性时，应该使用#。 建议在以下情况下使用$：

·当我们需要将参数直接替换到SQL语句中时，应该使用$。

如：SELECT * FROM user WHERE name = '${name}'。

·当我们需要在SQL语句中使用动态表名或列名时，应该使用$。如：SELECT * FROM ${tableName}。 需要注意的是，使用$的情况下，需要注意防止SQL注入攻击。因此，我们应该对参数进行严格的校验和过滤，避免参数中包含恶意字符。

- #{...}
  - 执行SQL时，会将#{…}替换为?，生成预编译SQL，会自动设置参数值
  - 使用时机：参数传递，都使用#{…}

- ${...}
  - 拼接SQL。直接将参数拼接在SQL语句中，存在SQL注入问题
  - 使用时机：如果对表名、列表进行动态设置时使用

### *参数传递

请求进来的参数 和javaBean对应 就用`javaBean`(pojo类)。

请求进来的参数 没有和javaBean对应 就用`map`。

请求进来的参数 没有和javaBean对应上 但使用频率很高，就用`TO、DTO`（单独为这些参数创建一个javaBean出来）。

javaBean是一个实体类，也叫pojo类

### *动态sql(常用)

- `<if>`：用于判断条件是否成立。使用test属性进行条件判断，如果条件为true，则拼接SQL。

```xml
<if test="（OGNL 的表达式）条件表达式">
   要拼接的sql语句
</if>
```

- `<where>`：只会在子元素有内容的情况下才插入where子句，而且会自动去除子句的开头的AND或OR
- `<set>`：动态的在SQL语句中插入set关键字，并会删掉额外的逗号。（用于update语句中）
- `<foreach>`：遍历deleteByIds方法中传递的参数ids集合。     (常用于批量插入)

```xml
<foreach collection="集合名称" item="集合遍历出来的元素/项" separator="每一次遍历使用的分隔符" 
         open="遍历开始前拼接的片段" close="遍历结束后拼接的片段">
</foreach>
```

- `<sql>`：定义可重用的SQL片段

  ```xml
  <sql id="commonSelect">
   	select id, username, password, name, gender, image, job, entrydate, dept_id, create_time, update_time from emp
  </sql>
  ```

  

- `<include>`：通过属性refid，指定包含的SQL片段

  ```xml
  <select id="list" resultType="com.itheima.pojo.Emp">
      <include refid="commonSelect"/>
      <where>
          <if test="name != null">
              name like concat('%',#{name},'%')
          </if>
          <if test="gender != null">
              and gender = #{gender}
          </if>
          <if test="begin != null and end != null">
              and entrydate between #{begin} and #{end}
          </if>
      </where>
      order by update_time desc
  </select>
  ```

  - 其它

```xml-dtd





 <trim prefix="where" prefixOverrides="and | or" suffixOverrides=","></trim>
 通过自定义 trim 元素来定制 where 元素的功能，移除所有 prefixOverrides 属性中指定的内容，并且插入 prefix 属性中指定的内容,
 suffixOverrides删掉额外的逗号.

  <choose>
    <when test="title != null">
    
    </when>
    <when test="author != null and author.name != null">
     
    </when>
    <otherwise>
   
    </otherwise>
  </choose>
```

### 小结

```
1_ 条件查询
   like name =concat('%',#{name},'%')
   like name ='%${name}%'
2) xml
   1) xml 文件名必须和接口的全名称一致(包.类)
   2) namepace 必须和 接口的全限定名一致
   3) 方法名必须和 xml 中的id 一致
   4) 返回值 resultType 和返回值类型一致(只有查询有)
   5) 参数paramterType 和参数类型一致 (可以省略)
   
3)
  if : 满足条件，拼接sql
  where  : 动态拼接where ,自动去除第一个无效的 and 或or   
  set  : 去除最后一个无效 ,
 <foreach collection="集合名称" item="集合遍历出来的元素/项" separator="每一次遍历使用的分隔符" 
         open="遍历开始前拼接的片段" close="遍历结束后拼接的片段">
</foreach>
  <sql id="name"> --- <include refid="name">
```



## 5.utils层

## 6.补充HTTP知识：Post、Get、Put、Delete

Http协议常用的四种请求方式：Post、Get、Put、Delete等；其中Put、Delete请求方式很少见，都可用Post方式代替！

- 对数据库而言： get 请求不修改数据库，只是查询。Post是增加记录，put是更新，Delete数据库删除；
- Put，Post，Delete 方式的请求参数会直接放在requestBody里；
- 处理 request uri 部分的注解，路径参数变量：@PathVariable；
- 处理request header部分的注解： @RequestHeader, @CookieValue，@RequestParam；
- 处理request body部分的注解：@RequestParam， @RequestBody；　　
- 综上所述：@RequestParam注解既可以接收Get方式的请求头中的参数，也可以接收Post方式的请求体中的参数；

#### **Accept**[#](https://www.cnblogs.com/codeluojay/p/13997558.html#2726998856)

Accept代表发送希望接受的数据类型

比如：Accept：application/json;

比如我们用浏览器发送请求中，请求头**Request Headers**带有`Accept：application/json;`,

那就是表明浏览器发送这个请求，希望服务器传送回的数据格式是json数据格式

#### **Content-Type**[#](https://www.cnblogs.com/codeluojay/p/13997558.html#2061145042)

Content-Type代表发送端发送的数据类型

比如：Content-Type：application/json;

**Response Headers**带有`Content-Type: application/json`就代表服务器希发送数据类型是json类型

**Request Headers**带有`Content-Type: application/json`就代表服务器希发送数据类型是json类型

#### **上述报文解释**[#](https://www.cnblogs.com/codeluojay/p/13997558.html#3227127724)

浏览器发送了POST请求，这次请求发送的数据格式是JSON数据给是，希望服务器能返回JSON的数据格式

服务器发送返回了JSON形式的数据格式数据给浏览器

#### 常见Content-Type媒体类型[#](https://www.cnblogs.com/codeluojay/p/13997558.html#3268065401)

Get请求的 headers 中没有 content-type 这个字段，Put、Delete和Post 请求的headers 是有 content-type 这个字段的

常见Content-Type媒体类型如下：

- application/x-www-form-urlencoded 这种就是一般的文本表单用 post 传地数据，

  只要将得到的 data 用 @RequestParam 或 request.getParamter() 获取即可；

- multipart/form-data ，用于文件上传，此时 form 的 enctype 属性必须指定为 multipart/form-data；

- application/json，将数据以json对象的格式传递；

- text/xml；

