## 1.生成器：它实际上是一个特殊的函数，他和普通函数的区别：

（1）书写的时候，函数名之前有一个 * （即function *xxx（））。

（2）在函数里面，可以用yield将函数暂停执行，需要它执行的时候可以用next来恢复执行。这个不是很熟练，可以用于异步执行防止出现一个“回调地狱”。写一个实例：

```javascript

//生成器的实例
function one() {
   setTimeout(() => {
   console.log(111);
   iterator.next();
   }, 1000);
}   
function two(){
   setTimeout(() => {
   console.log(222);
   iterator.next();
   }, 2000);
}    
function three(){
   setTimeout(() => {
   console.log(333)
   iterator.next();
   }, 3000);
}
function *gen() {
   yield one();
   yield two();
   yield three();
}
let iterator = gen();
iterator.next();
https://blog.csdn.net/aghwvbn
```

## 2.every遍历数组，判断购物车是否全选

商品数组 每一项都有一个属性代表此件商品有没有被选中

使用 every 遍历数组的这一项 ， return 条件是 当前项被选中

```js
isAllChecked(){

// 是否全选 ， every监测 数组cartList中的isChecked是否为1，只有所有数组项的isChecked为 1 ， every函数的返回值才为1

let result = this.cartList.every(item=>{

return item.isChecked == 1

})

return result

}
```

## some

some() 方法用于检测数组中的元素是否满足指定条件（函数提供）。

some() 方法会依次执行数组的每个元素：

如果有一个元素满足条件，则表达式返回true , 剩余的元素不会再执行检测。
如果没有满足条件的元素，则返回false。
注意： some() 不会对空数组进行检测。

注意： some() 不会改变原始数组。
```js
router.beforeEach((to, from, next) => {
  if (to.matched.some(r => r.meta.requireAuth)) {          
    meta:{requireAuth:true}
    if (Cookies.get('Token')) {
        next();
    } else {
        next({
            path: '/login',
            query: {redirect: to.fullPath}
        })
    }
  } else {
    next();
  }
})
```



## 3.世界生产总线（慎用）

在之前我们只用过父传子，子传父进行传数据，这时候当组件嵌套比较深或比较复杂的情况，这时候就用到了***事件总线** (EventBus)*

1. 任何组件都可以在事件总线中发布事件 this.$bus.$emit('xxx','传递参数') 

2. 任何组件都可以在事件总线中监听事件 this.$bus.$on('xxx',(接收参数)=>{ 对形参进行操作 }) 

3. main.js注册空的Vue对象（ Vue.prototype.$bus=new Vue()  ）, 只负责$on注册事件, $emit触发事件, 一定要确保$on先执行

4. 使用eventBus要及时调用$off,否则严重可能造成导致内存泄漏

4.$off的格式：

$off() 会取消所有的事件订阅；

$off('事件名') 会取消指定事件名的；

$off('事件名', 回调) 会取消指定事件名的，指定回调

## 4.导航守卫

```js
// GOOD
router.beforeEach((to, from, next) => {
     // 用户验证身份
  if (to.name !== 'Login' && !isAuthenticated) next({ name: 'Login' })
    
  else next()
})

```

## 6.promise对象

就是promise().then().catch()这种

async异步，await等待

## 7.Sort方法解决排序问题

```js
       onClick() {
            const n=this.num;
            if (n == 0) {
                //升序
                this.cartList.sort((a, b) => {
                    return a.price - b.price 
                })
                this.num = 1
            } else if(n== 1){
                //降序
                this.cartList.sort((a, b) => {
                    return b.price - a.price
                })
                this.num =0
                
            }
        }
```

