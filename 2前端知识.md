# Vue 

@   ===   /src

## 传值

props用来接收父组件中定义的数据   父  -> 子组件传值   自定义属性     相当于函数参数的存放地，而组件是一个函数，用组件就是调用函数（以标签的形式）  

this.$emit    子 -> 父组件传值   自定义事件     this.$emit('自定义事件的名字', 传参数)

<slot>    插槽 相当于自定义组件 用来接受组件闭合式写法传入的内容 

data（）{

里面的数据会复制到Vue实例中

}

## 简写

v-on        @      这里的函数需要在构造Vue实例的时候在`methods`属性中声明

v-bind      :     绑定HTML标签属性

v-slot      #

v-for                v-for="item in items"      列表渲染  

v-for指令本身写在哪个标签上就循环输出哪个标签要输出循环的内容，还需要结合{{}}语法来输出。

v-for不仅可以应用于数组，它还可以对对象进行循环，遍历对象，对象有几个属性，就会生成多少个li，其中第一个参数代表的是健值，第二个参数代表健名。

v-if                                                              条件渲染

v-model          用于表单，将数据和页面元素进行双向绑定    实现mvvm

## 知识

文本插值{{}}只能插入文本，如果需要设置和修改HTML属性的话，需要使用`v-bind`指令。

重点1：{{}}双括号中的内容只要是js表达式都可以。

重点2： 在{{}}中输出的变量，必须是在data中来定义好的。

el

data                                                  组件的`data`属性必须是一个函数

methods

- 调用methods定义的方法的时候，直接像执行函数一样就可以了。
- 在methods中定义的方法，是通过this指针去访问data中的数据的。

computed 惰性求值

总体就是一句话，在使用的时候，感觉像属性，在定义的时候，感觉像方法。计算属性的本质就是方法。和方法有什么区别呢？和方法相比，计算属性的性能更高，因为它有缓存。

slot      插槽                                         用于接收组件传入的内容 

如果需要从父组件中传递数据，需要在子组件中声明`props`属性制定要传入的数据。



assets文件夹存放的是项目所需的静态文件，例如图片、样式表等。

components文件夹是Vue组件的存放位置。App.vue是项目默认的跟组件。

**App.vue是项目的主组件，\**页面入口文件\** ，所有页面都在App.vue下进行切换，app.vue负责构建定义及页面组件归集。**

main.js是项目的入口JavaScript文件，在全局Vue实例中注册东西

package.json 查看该项目安装的全部依赖

## 跳转页面

​    this.$router.push({})

​    this.$router.replace({})

​    静态 to="/" 动态  :to="{ name=' ' }"

### 导入导出

`require`: node 和 es6 都支持的引入
export/export default / import `: 只有es6 支持的导出引入` 

module.exports / exports`: 只有 node 支持的导出

#### 

### 属性的简介表达式



**ES6 允许在对象之中，直接写变量。这时，属性名为变量名, 属性值为变量的值**



### 原型链

vue.prototype.$http = axios

这行代码的作用是在Vue实例的原型对象上添加一个名为$http的属性，其值为axios库的实例。这样，在Vue组件中就可以通过this.$http来调用axios库提供的方法，例如发起HTTP请求等。

在 JavaScript 中，使用 export 关键字导出模块时，需要导出一个对象或函数，而不是一个单独的变量或值。因此，导出 1 或 m 这样的单独变量是不合法的，会导致语法错误。

如果你想导出一个单独的变量，可以将它包装在一个对象中，然后将该对象导出。

###### 虽然可以通过 `import * as config from '@/config'` 将模块中的所有导出都绑定到 `config` 对象上，但是这种方式会导致命名空间污染和模块的不可预测性。

如果模块中有多个导出，你可能只需要其中的一个或几个，但使用 `import *` 会将所有导出都加载进来，这可能会导致性能问题。

建议按需导入模块的导出，例如 `import { config1, config2 } from '@/config'`，这样可以显式地指定要使用的导出，同时避免了命名空间污染和性能问题。

因为在Node.js中使用的是CommonJS规范，而在ES6中使用的是ES6 Module规范。两种规范虽然有区别，但是在实现上都会将模块的导出和引入转换成对象的形式，因此使用module.exports和import都可以正常工作。不过需要注意的是，在Node.js中使用import需要使用Babel等工具进行转换。



