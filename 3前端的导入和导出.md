[TOC]

# 前端的导入和导出

## 1.ES6模块（主流）

### https://es6.ruanyifeng.com/#docs/module

### ⑴.export

①用于导出函数、常量、文件、模块等。

②在一个文件或模块中，export可以有***多个。***

③通过export方式导出，在导入时***要***加{ }。

④在导出多个值时，(export)命名导出非常有用，在导入期间，必须使用相应对象的***相同名称***。

在 JavaScript 中，使用 export 关键字导出模块时，需要导出一个对象或函数，而不是一个单独的变量或值。因此，导出 1 或 m 这样的单独变量是不合法的，会导致语法错误。

如果你想导出一个单独的变量，可以将它包装在一个对象中，然后将该对象导出。

### ⑵.export default 

①用于导出函数、常量、文件、模块等。

②在一个文件或模块中，export default***仅有一个。***

③通过export default方式导出***不需要***加{ }。

④可以使用***任何名称***导入（export default）默认导出。

### ⑶.import

1.在一个文件或模块中，import可以有多个。

2.动态import()

更多见下   ES6 模块与 CommonJS 模块的差异

更多import细节https://blog.csdn.net/fyyyr/article/details/83657828

###  ⑷.以上只有es6 支持的导出引入

1. export与export default均可用于导出常量、函数、文件、模块等

2. 在一个文件或模块中，export、import可以有多个，export default仅有一个

3. 通过export方式导出，在导入时要加{ }，export default则不需要

4. export能直接导出变量表达式，export default不行。

5. 在导出多个值时，(export)命名导出非常有用，在导入期间，必须使用相应对象的相同名称。

   但是，可以使用任何名称导入（export default）默认导出。

   详情https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Statements/export

## 2.CommonJs模块（即将淘汰）

### https://javascript.ruanyifeng.com/nodejs/module.html#

### ⑴.module.exports 与 exports`: 只有 node 支持的导出

***优先使用 module.exports***

在一个node执行一个文件时，会给这个文件内生成一个 `exports`和`module`对象，
而`module`又有一个`exports`属性。他们之间的关系如下图，都指向一块{}内存区域。

```js
exports = module.exports = {};
```

<img src="https://segmentfault.com/img/bVRMVd?w=596&h=166" alt="clipboard.png"  />



其实`require`导出的内容是`module.exports`的指向的内存块内容，并不是`exports`的。
简而言之，区分他们之间的区别就是 `exports` 只是 `module.exports`的引用，辅助后者添加内容用的。

用白话讲就是，`exports`只辅助`module.exports`操作内存中的数据，辛辛苦苦各种操作数据完，累得要死，结果到最后真正被`require`出去的内容还是`module.exports`的，真是好苦逼啊。

其实大家用内存块的概念去理解，就会很清楚了。

然后呢，为了避免糊涂，尽量都用 `module.exports` 导出，然后用`require`导入。

### ⑵.`require`: node 和 es6 都支持的引入

1.require是运行时的、同步加载、该对象只有在脚本运行完才会生成。

2.require是赋值过程

## 3.[import和require](https://www.cnblogs.com/cina33blogs/p/7250105.html)

es6 的 import 语法跟 require 不同，而且 import 必须放在文件的最开始，且前面不允许有其他逻辑代码，这和其他所有编程语言风格一致。

import不同与require，它是编译时的（require是运行时的），它必须放在文件开头，而且使用格式也是确定的。它不会将整个模块运行后赋值给某个变量，而是只选择import的接口进行编译，这样在性能上比require好很多。

从理解上，require是赋值过程，import是解构过程。

“该用require还是import？”这个问题，就目前而言，根本没法回答。
因为目前所有的引擎都还没有实现import，我们在node中使用babel支持ES6，也仅仅是将ES6转码为ES5再执行，**import语法会被转码为require**。这也是为什么在模块导出时使用module.exports，在引入模块时使用import仍然起效，因为本质上，import会被转码为require去执行。



## 4.ES6 模块与 CommonJS 模块的差异

讨论 Node.js 加载 ES6 模块之前，必须了解 ES6 模块与 CommonJS 模块完全不同。

它们有三个重大差异。

- CommonJS 模块输出的是一个值的拷贝，ES6 模块输出的是值的引用。
- CommonJS 模块是运行时加载，ES6 模块是编译时输出接口。
- CommonJS 模块的`require()`是同步加载模块，ES6 模块的`import`命令是异步加载，有一个独立的模块依赖的解析阶段。

第二个差异是因为 CommonJS 加载的是一个对象（即`module.exports`属性），该对象只有在脚本运行完才会生成。而 ES6 模块不是对象，它的对外接口只是一种静态定义，在代码静态解析阶段就会生成。

## 5.在Node.js中使用的是CommonJS规范，而在ES6中使用的是ES6 Module规范

两种规范虽然有区别，但是在实现上都会将模块的导出和引入转换成对象的形式，因此使用module.exports和import都可以正常工作。不过需要注意的是，在Node.js中使用import需要使用Babel等工具进行转换。

